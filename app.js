//Флаги

//i
//С этим флагом поиск не зависит от регистра

//g
//С этим флагом поиск ищет все совпадения, без него – только первое.

let str1 = "Любо, братцы, любо!";
// Поиск: str.match()
console.log(str1.match(/любо/gi)); // Любо,любо (массив из 2х подстрок-совпадений)

// Замена: str.replace()
// без флага g
console.log("We will, we will".replace(/we/i, "I")); // I will, we will

// с флагом g
console.log("We will, we will".replace(/we/gi, "I")); // I will, I will

// Спецсимволы	Действие в строке замены
// $&	вставляет всё найденное совпадение
// $`	вставляет часть строки до совпадения
// $'	вставляет часть строки после совпадения
// $n	если n это 1-2 значное число, вставляет содержимое n-й скобочной группы регулярного выражения, больше об этом в главе Скобочные группы
// $<name>	вставляет содержимое скобочной группы с именем name, также изучим в главе Скобочные группы
// $$	вставляет символ "$"

console.log("Люблю HTML".replace(/HTML/, "$& и JavaScript")); // Люблю HTML и JavaScript

//Проверка: regexp.test()
//Метод regexp.test(str) проверяет, есть ли хоть одно совпадение, если да, то возвращает true, иначе false.
let str2 = "Я ЛюБлЮ JavaScript";
let regexp2 = /люблю/i;

console.log(regexp2.test(str2)); // true

//Символьные классы

//\d соответствует «любой одной цифре»

let str3 = "+7(903)-123-45-67";

let regexp3 = /\d/;

console.log(str3.match(regexp3)); // 7

// найти все цифры
let regexp4 = /\d/g;

console.log(str3.match(regexp4)); // массив совпадений: 7,9,0,3,1,2,3,4,5,6,7

// и можно сделать из них уже чисто цифровой номер телефона
console.log(str3.match(regexp4).join("")); // 79031234567

// \d («d» от английского «digit» означает «цифра»)
// Цифра: символ от 0 до 9.

// \s («s»: от английского «space» – «пробел»)
// Пробельные символы: включает в себя символ пробела, табуляции \t, перевода строки \n и некоторые другие редкие пробельные символы, обозначаемые как \v, \f и \r.

// \w («w»: от английского «word» – «слово»)
// Символ «слова», а точнее – буква латинского алфавита или цифра или подчёркивание _. Нелатинские буквы не являются частью класса \w, то есть буква русского алфавита не подходит.

// Обратные символьные классы
// Для каждого символьного класса существует «обратный класс», обозначаемый той же буквой, но в верхнем регистре.

// «Обратный» означает, что он соответствует всем другим символам, например:

// \D
// Не цифра: любой символ, кроме \d, например буква.

// \S
// Не пробел: любой символ, кроме \s, например буква.

// \W
// Любой символ, кроме \w, то есть не буквы из латиницы, не знак подчёркивания и не цифра. В частности, русские буквы принадлежат этому классу.

let str4 = "+7(903)-123-45-67";
// найти нецифровые символы \D и удалить их из строки
console.log(str4.replace(/\D/g, "")); // 79031234567

//Точка – это любой символ, кроме новой строки
let regexp5 = /CS.4/;

console.log("CSS4".match(regexp5)); // CSS4
console.log("CS-4".match(regexp5)); // CS-4
console.log("CS 4".match(regexp5)); // CS 4 (пробел тоже является символом)

// s
//Если регулярное выражение имеет этот флаг, то точка . соответствует буквально любому символу

console.log("A\nB".match(/A.B/s)); // A\nB (совпадение!)

// Юникод: флаг "u" и класс \p{...}

let str6 = "A ბ ㄱ";

console.log(str6.match(/\p{L}/gu)); // A,ბ,ㄱ
console.log(str6.match(/\p{L}/g)); // null (ничего не нашло, так как \p не работает без флага "u")

// Вот основные категории символов и их подкатегории:

// Буквы L:
// в нижнем регистре Ll,
// модификаторы Lm,
// заглавные буквы Lt,
// в верхнем регистре Lu,
// прочие Lo.

// Числа N:
// десятичная цифра Nd,
// цифры обозначаемые буквами (римские) Nl,
// прочие No.

// Знаки пунктуации P:
// соединители Pc,
// тире Pd,
// открывающие кавычки Pi,
// закрывающие кавычки Pf,
// открывающие скобки Ps,
// закрывающие скобки Pe,
// прочее Po.

// Отметки M (например, акценты):
// двоеточия Mc,
// вложения Me,
// апострофы Mn.

// Символы S:
// валюты Sc,
// модификаторы Sk,
// математические Sm,
// прочие So.

// Разделители Z:
// линия Zl,
// параграф Zp,
// пробел Zs.

// Прочие C:
// контрольные Cc,
// форматирование Cf,
// не назначенные Cn,
// для приватного использования Co,
// суррогаты Cs

let regexp7 = /\p{sc=Han}/gu; // вернёт китайские иероглифы

let str7 = `Hello Привет 你好 123_456`;

console.log(str7.match(regexp7)); // 你,好

// Якоря: начало строки ^ и конец $

let str8 = "Mary had a little lamb";
console.log(/^Mary/.test(str8)); // true
let str9 = "it's fleece was white as snow";
console.log(/snow$/.test(str9)); // true

//Оба якоря вместе ^...$ часто используются для проверки, совпадает ли строка с шаблоном полностью.

let goodInput = "12:34";
let badInput = "12:345";

let regexp8 = /^\d\d:\d\d$/;
console.log(regexp8.test(goodInput)); // true
console.log(regexp8.test(badInput)); // false

//Многострочный режим якорей ^ $, флаг "m"
// Он влияет только на поведение ^ и $.

// В многострочном режиме они означают не только начало/конец текста, но и начало/конец каждой строки в тексте.

let str10 = `1е место: Винни
2е место: Пятачок
3е место: Слонопотам`;

console.log(str10.match(/^\d/gm)); // 1, 2, 3

let str11 = `Винни: 1
Пятачок: 2
Слонопотам: 3`;

console.log(str11.match(/\d$/gm)); // 1,2,3

// Граница слова: \b

console.log("Hello, Java!".match(/\bJava\b/)); // Java
console.log("Hello, JavaScript!".match(/\bJava\b/)); // null

let str12 = "Завтрак в 09:00 в комнате 123:456.";

console.log(str12.match(/\b\d\d:\d\d\b/gm)); //09:00

// Полный перечень всех спецсимволов
// [ ] \ ^ $ . | ? * + ( )

// экранирование спецсимволов
console.log("Глава 5.1".match(/\d\.\d/)); // 5.1 (совпадение!)
console.log("Глава 511".match(/\d\.\d/)); // null ("\." - ищет обычную точку)
console.log("function g()".match(/g\(\)/)); // "g()"
console.log("/".match(/\//)); // '/'

// Здесь экранировать не нужно
console.log("/".match(new RegExp("/"))); // находит /

// Не работает, символы обратной косой черты «съедаются» строкой
let regexp9 = new RegExp("d.d");

console.log("Глава 5.1".match(regexp9)); // null

// Чтобы исправить это, нам нужно удвоить обратную косую черту, потому что строковые кавычки превращают \\ в \

let regStr = "\\d\\.\\d";
console.log(regStr); // \d\.\d (теперь правильно)

let regexp10 = new RegExp(regStr);

console.log("Глава 5.1".match(regexp10)); // 5.1

// Наборы и диапазоны [...]

// найти [т или х], после которых идёт "оп"
console.log("Топ хоп".match(/[тх]оп/gi)); // "Топ", "хоп"

// Ещё квадратные скобки могут содержать диапазоны символов.

console.log("Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g)); // xAF

// \d – то же самое, что и [0-9],
// \w – то же самое, что и [a-zA-Z0-9_],
// \s – то же самое, что и [\t\n\v\f\r ], плюс несколько редких пробельных символов Юникода.

// многоязычный аналог \w

let regexp11 = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu;
// Alphabetic (Alpha) – для букв,
// Mark (M) – для акцентов,
// Decimal_Number (Nd) – для цифр,
// Connector_Punctuation (Pc) – для символа подчёркивания '_' и подобных ему,
// Join_Control (Join_C) – два специальных кода 200c и 200d, используемые в лигатурах, например, арабских.
let str13 = `Hi 你好 12`;

// найдены все буквы и цифры
console.log(str13.match(regexp11)); // H,i,你,好,1,2

// Исключающие диапазоны

// [^aeyo] – любой символ, за исключением 'a', 'e', 'y' или 'o'.
// [^0-9] – любой символ, за исключением цифры, то же, что и \D.
// [^\s] – любой непробельный символ, то же, что и \S.

// Пример ниже ищет любые символы, кроме латинских букв, цифр и пробелов
console.log("alice15@gmail.com".match(/[^\d\sA-Z]/gi)); // @ и .

// Экранирование внутри […]
// Нет необходимости в экранировании
let regexp12 = /[-().^+]/g;

console.log("1 + 2 - 3".match(regexp12)); // Совпадения +, -

let regexp13 = /\d\d[-:]\d\d/g;
console.log("Завтрак в 09:00. Ужин в 21-30".match(regexp13)); // 09:00, 21-30

// Квантификаторы +, *, ? и {n}

// Точное количество: {5}

console.log("Мне 1234586 лет".match(/\d{5}/)); //  "12345"

// Диапазон: {3,5}, от 3 до 5

console.log("Мне не 12, а 1234 года".match(/\d{3,5}/)); // "1234"

// шаблон \d{3,} найдёт последовательность чисел длиной 3 и более цифр

let str14 = "+7(903)-123-45-67";

console.log(str14.match(/\d{1,}/g)); // 7,903,123,45,67

//Короткие обозначения

// +
// Означает «один или более». То же самое, что и {1,}

// Например, \d+ находит числа (из одной или более цифр)

// ?
// Означает «ноль или один». То же самое, что и {0,1}. По сути, делает символ необязательным.

let str = "Следует писать color или colour?";

console.log(str.match(/colou?r/g)); // color, colour

// *
// Означает «ноль или более». То же самое, что и {0,}. То есть символ может повторяться много раз или вообще отсутствовать.

console.log("100 10 1".match(/\d0*/g)); // 100, 10, 1
console.log("100 10 1".match(/\d0+/g)); // 100, 10

//Регулярное выражение для десятичных дробей (чисел с плавающей точкой): \d+\.\d+
console.log("0 1 12.345 7890".match(/\d+\.\d+/g)); // 12.345

// Регулярное выражение для «открывающего HTML-тега без атрибутов», например, <span> или <p>.

// простое
console.log("<body> ... </body>".match(/<[a-z]+>/gi)); // <body>
// улучшенное
console.log("<h1>Привет!</h1>".match(/<[a-z][a-z0-9]*>/gi)); // <h1>

// Регулярное выражение для «открывающего или закрывающего HTML-тега без атрибутов»: /<\/?[a-z][a-z0-9]*>/i

console.log("<h1>Привет!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi)); // <h1>, </h1>

// Жадные и ленивые квантификаторы

// жадный поиск
let regexp14 = /".+"/g;

let str15 = 'a "witch" and her "broom" is one';

console.log(str15.match(regexp14)); // "witch" and her "broom"

// ленивый поиск
let regexp15 = /".+?"/g;

console.log(str15.match(regexp15)); // witch, broom

// альтернатива ленивому поиску, ищет не кавычки между кавычками
let regexp16 = /"[^"]+"/g;

console.log(str15.match(regexp16)); // witch, broom

// Скобочные группы

console.log("Gogogo now!".match(/(go)+/gi)); // "Gogogo"

// Пример: домен
let regexp17 = /(\w+\.)+\w+/g;

console.log("site.com, my.site.com,".match(regexp17)); // site.com,my.site.com
// когда вместо точки тире
regexp17 = /([\w-]+\.)+\w+/g;

console.log("site.com, my-site.com,".match(regexp17)); //site.com, my-site.com

// Пример: email
let regexp18 = /[-.\w]+@([\w-]+\.)+[\w-]+/g;

console.log("my@mail.com @ his@site.com.uk".match(regexp18)); // my@mail.com, his@site.com.uk

// Содержимое скобок в match()

let str16 = "<h1>Hello, world!</h1>";

// получим как тег целиком <h1>, так и его содержимое h1 в виде массива
let tag = str16.match(/<(.*?)>/);

console.log(tag[0]); // <h1>
console.log(tag[1]); // h1

let str17 = '<span class="my">';

let regexp19 = /<(([a-z]+)\s*([^>]*))>/;

let result = str17.match(regexp19);
console.log(result[0]); // <span class="my">
console.log(result[1]); // span class="my"
console.log(result[2]); // span
console.log(result[3]); // class="my"

// Необязательные группы
let match = "ac".match(/a(z)?(c)?/);

console.log(match.length); // 3
console.log(match[0]); // a (всё совпадение)
console.log(match[1]); // undefined
console.log(match[2]); // c

// Поиск всех совпадений с группами: matchAll()

let results = "<h1> <h2>".matchAll(/<(.*?)>/gi);

// results - не массив, а перебираемый объект
console.log(results); // [object RegExp String Iterator]

console.log(results[0]); // undefined (*)

results = Array.from(results); // превращаем в массив

console.log(results[0]); // <h1>,h1 (первый тег)
console.log(results[1]); // <h2>,h2 (второй тег)

let results1 = "<h1> <h2>".matchAll(/<(.*?)>/gi);

// перебор объекта в цикле
for (let result of results1) {
  console.log(result);
  // первый вывод: <h1>,h1
  // второй: <h2>,h2
}
// можно использовать деструктуризацию
let [tag1, tag2] = "<h1> <h2>".matchAll(/<(.*?)>/gi);
console.log(tag1);
console.log(tag2);

// Почему результат matchAll – перебираемый объект, а не обычный массив?
// Зачем так сделано? Причина проста – для оптимизации.

// При вызове matchAll движок JavaScript возвращает перебираемый объект, в котором ещё нет результатов. Поиск осуществляется по мере того, как мы запрашиваем результаты, например, в цикле.

// Таким образом, будет найдено ровно столько результатов, сколько нам нужно.

// Например, всего в тексте может быть 100 совпадений, а в цикле после 5-го результата мы поняли, что нам их достаточно и сделали break. Тогда движок не будет тратить время на поиск остальных 95.

//Именованные группы

// Имена группам даются путем добавления в скобках ?<name>

let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;
let str19 = "2019-04-30";

let groups = str19.match(dateRegexp).groups;

console.log(groups.year); // 2019
console.log(groups.month); // 04
console.log(groups.day); // 30

// Чтобы найти не только первую дату, используем флаг g.

// Также нам понадобится matchAll, чтобы получить скобочные группы

let dateRegexp1 = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

let str20 = "2019-10-30 2020-01-01";

let results2 = str20.matchAll(dateRegexp1);

for (let result of results2) {
  let { year, month, day } = result.groups;

  console.log(`${day}.${month}.${year}`);
  // первый вывод: 30.10.2019
  // второй: 01.01.2020
}

// Скобочные группы при замене

// Метод str.replace(regexp, replacement), осуществляющий замену совпадений с regexp в строке str, позволяет использовать в строке замены содержимое скобок. Это делается при помощи обозначений вида $n, где n – номер скобочной группы.

// Например:
let str21 = "John Bull";
let regexp21 = /(\w+) (\w+)/;

console.log(str21.replace(regexp21, "$2, $1")); // Bull, John

// Для именованных скобок ссылка будет выглядеть как $<имя>.
let regexp22 = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

let str22 = "2019-10-30, 2020-01-01";

console.log(str22.replace(regexp22, "$<day>.$<month>.$<year>"));
// 30.10.2019, 01.01.2020

// Исключение из запоминания через ?:

let str23 = "Gogogo John!";

// ?: исключает go из запоминания
let regexp23 = /(?:go)+ (\w+)/i;

let result3 = str23.match(regexp23);

console.log(result3[0]); // Gogogo John (полное совпадение)
console.log(result3[1]); // John
console.log(result3.length); // 2 (больше в массиве элементов нет)

regexp = /^([\da-f]{2}:){5}[\da-f]{2}$/gi;

console.log(regexp.test("01:32:54:67:89:AB")); // true

console.log(regexp.test("0132546789AB")); // false (нет двоеточий)

console.log(regexp.test("01:32:54:67:89")); // false (5 чисел, должно быть 6)

console.log(regexp.test("01:32:54:67:89:ZZ")); // false (ZZ в конце строки)

regexp = /#([a-f0-9]{3}){1,2}/gi;

str = "color: #3f3; background-color: #AA00ef; and: #abcd";

console.log(str.match(regexp)); // #3f3 #AA00ef #abc

function parse(expr) {
  let regexp = /(-?\d+(?:\.\d+)?)\s*([-+*\/])\s*(-?\d+(?:\.\d+)?)/;

  let result = expr.match(regexp);

  if (!result) return [];
  result.shift();

  return result;
}

console.log(parse("-1.23 * 3.45")); // -1.23, *, 3.45

// Обратная ссылка по номеру: \N

let str24 = `He said: "She's the one!".`;

let regexp24 = /['"](.*?)['"]/g;

// Результат - не тот, который хотелось бы
console.log(str24.match(regexp24)); // "She'
// обернём открывающие кавычки в скобочную группу и используем обратную ссылку на неё
regexp24 = /(['"])(.*?)\1/g;
// \1 означает «найти то же самое, что в первой скобочной группе»
console.log(str24.match(regexp24));

//Обратная ссылка по имени: \k<имя>

let str25 = `He said: "She's the one!".`;

let regexp25 = /(?<quote>['"])(.*?)\k<quote>/g;

console.log(str25.match(regexp25)); // "She's the one!"

// Альтернация (или) |

let regexp26 = /html|css|java(script)?/gi;

let str26 = "Сначала появился язык Java, затем HTML, потом JavaScript";

console.log(str26.match(regexp26)); // Java,HTML,JavaScript

// Пример: шаблон для времени
// Шаблон для часов /[01]\d|2[0-3]/
// Шаблон для минут /[0-5]\d/
let regexp27 = /([01]\d|2[0-3]):[0-5]\d/g;

console.log("00:00 10:10 23:59 25:99 1:2".match(regexp27)); // 00:00,10:10,23:59

let regexp28 = /Java(Script)?|C(\+\+)?|PHP/g;

let str28 = "Java, JavaScript, PHP, C, C++";

console.log(str28.match(regexp28)); // Java,JavaScript,PHP,C,C++

// Опережающие и ретроспективные проверки

// Опережающая проверка
// Синтаксис опережающей проверки: X(?=Y).

// Он означает: найди X при условии, что за ним следует Y. Вместо X и Y здесь может быть любой шаблон.
let str29 = "1 индейка стоит 30€";

console.log(str29.match(/\d+(?=€)/)); // 30, число 1 проигнорировано, так как за ним НЕ следует €

// Возможны и более сложные проверки, например X(?=Y)(?=Z) означает:

// Найти X.
// Проверить, идёт ли Y сразу после X (если нет – не подходит).
// Проверить, идёт ли Z сразу после X (если нет – не подходит).
// Если обе проверки прошли – совпадение найдено.

// Например, \d+(?=\s)(?=.*30) ищет \d+ при условии, что за ним идёт пробел, и где-то впереди есть 30:
console.log(str29.match(/\d+(?=\s)(?=.*30)/)); // 1

// Негативная опережающая проверка
// Синтаксис: X(?!Y)

// Он означает: найди такой X, за которым НЕ следует Y.

str29 = "2 индейки стоят 60€";

console.log(str29.match(/\d+(?!€)/)); // 2 (в этот раз проигнорирована цена)

// Ретроспективная проверка
// Синтаксис:

// Позитивная ретроспективная проверка: (?<=Y)X, ищет совпадение с X при условии, что перед ним ЕСТЬ Y.
// Негативная ретроспективная проверка: (?<!Y)X, ищет совпадение с X при условии, что перед ним НЕТ Y.

let str30 = "1 индейка стоит $30";

// знак доллара экранируем \$, так как это специальный символ
console.log(str30.match(/(?<=\$)\d+/)); // 30, одинокое число игнорируется

str30 = "2 индейки стоят $60";

console.log(str30.match(/(?<!\$)\d+/)); // 2 (проигнорировалась цена)

// Поиск на заданной позиции, флаг "y"

let str31 = "let varName";

let regexp31 = /\w+/g;
console.log(regexp.lastIndex); // 0 (при создании lastIndex=0)

let word1 = regexp31.exec(str31);
console.log(word1); // let (первое слово)
console.log(regexp31.lastIndex); // 3 (позиция за первым совпадением)

let word2 = regexp31.exec(str31);
console.log(word2); // varName (второе слово)
console.log(regexp31.lastIndex); // 11 (позиция за вторым совпадением)

let word3 = regexp31.exec(str31);
console.log(word3); // null (больше совпадений нет)
console.log(regexp31.lastIndex); // 0 (сбрасывается по окончании поиска)

let str32 = 'let varName = "value"';

let regexp32 = /\w+/y;

regexp32.lastIndex = 3;
console.log(regexp32.exec(str32)); // null (на позиции 3 пробел, а не слово)

regexp32.lastIndex = 4;
console.log(regexp32.exec(str32)); // varName (слово на позиции 4)

// Методы RegExp и String

//Метод str.match(regexp) ищет совпадения с regexp в строке str

// Если у регулярного выражения нет флага g, то он возвращает первое совпадение в виде массива со скобочными группами и свойствами index (позиция совпадения), input (строка поиска, равна str):
let str33 = "I love JavaScript";

let result33 = str33.match(/Java(Script)/);
console.log(result33);

// Если у регулярного выражения есть флаг g, то он возвращает массив всех совпадений, без скобочных групп и других деталей.
result33 = str33.match(/Java(Script)/g);
console.log(result33);

// Если совпадений нет, то, вне зависимости от наличия флага g, возвращается null.
// Если хочется, чтобы результатом всегда был массив, можно написать так:
result33 = str33.match(/html/) || [];
console.log(result33);

// Метод str.matchAll(regexp) – «новый, улучшенный» вариант метода str.match.

// У него 3 отличия от match:

// Он возвращает не массив, а перебираемый объект с результатами, обычный массив можно сделать при помощи Array.from.
// Каждое совпадение возвращается в виде массива со скобочными группами (как str.match без флага g).
// Если совпадений нет, то возвращается не null, а пустой перебираемый объект.

// str.split(regexp|substr, limit)
// Разбивает строку в массив по разделителю – регулярному выражению regexp или подстроке substr.

// Обычно мы используем метод split со строками, вот так:
console.log("12-34-56".split("-")); // массив [12, 34, 56]
// Но мы можем разделить по регулярному выражению аналогичным образом:
console.log("12, 34, 56".split(/,\s*/)); // массив [12, 34, 56]

// str.search(regexp)
// Метод str.search(regexp) возвращает позицию первого совпадения с regexp в строке str или -1, если совпадения нет.
// Например:
str = "Я люблю JavaScript!";

regexp = /Java.+/;

console.log(str.search(regexp)); // 8

// str.replace(str|regexp, str|func)
// Это универсальный метод поиска-и-замены, один из самых полезных.

// Мы можем использовать его и без регулярных выражений, для поиска-и-замены подстроки:

// заменить тире двоеточием
console.log("12-34-56".replace("-", ":")); // 12:34-56

//Чтобы найти все дефисы, нам нужно использовать не строку "-", а регулярное выражение /-/g с обязательным флагом g:
console.log("12-34-56".replace(/-/g, ":")); // 12:34:56

// Для ситуаций, которые требуют «умных» замен, вторым аргументом может быть функция.
// Например, переведём выбранные совпадения в верхний регистр:
str = "html and css";

result = str.replace(/html|css/gi, (str) => str.toUpperCase());
console.log(result); // HTML and CSS
// Заменим каждое совпадение на его позицию в строке:
console.log("Хо-Хо-хо".replace(/хо/gi, (match, offset) => offset)); // 0-3-6

// В примере ниже две скобки, поэтому функция замены вызывается с 5-ю аргументами: первый – всё совпадение, затем два аргумента содержимое скобок, затем (в примере не используются) индекс совпадения и исходная строка:
str = "John Smith";

result = str.replace(
  /(\w+) (\w+)/,
  (match, name, surname) => `${surname}, ${name}`
);
console.log(result); // Smith, John
// Если в регулярном выражении много скобочных групп, то бывает удобно использовать остаточные аргументы для обращения к ним:

result = str.replace(/(\w+) (\w+)/, (...match) => `${match[2]}, ${match[1]}`);

console.log(result); // Smith, John

// Или, если мы используем именованные группы, то объект groups с ними всегда идёт последним, так что можно получить его так:
result = str.replace(/(?<name>\w+) (?<surname>\w+)/, (...match) => {
  let groups = match.pop();

  return `${groups.surname}, ${groups.name}`;
});

console.log(result); // Smith, John
// Использование функции даёт нам максимальные возможности по замене, потому что функция получает всю информацию о совпадении, имеет доступ к внешним переменным и может делать всё что угодно.

// Метод regexp.exec(str) ищет совпадение с regexp в строке str. В отличие от предыдущих методов, вызывается на регулярном выражении, а не на строке.

// Если нет флага g, то regexp.exec(str) возвращает первое совпадение в точности как str.match(regexp)

// Но если есть g, то:
// Вызов regexp.exec(str) возвращает первое совпадение и запоминает позицию после него в свойстве regexp.lastIndex.
// Следующий такой вызов начинает поиск с позиции regexp.lastIndex, возвращает следующее совпадение и запоминает позицию после него в regexp.lastIndex.
// …И так далее.
// Если совпадений больше нет, то regexp.exec возвращает null, а для regexp.lastIndex устанавливается значение 0.

str = "Больше о JavaScript на https://javascript.info";
regexp = /javascript/gi;

let result34;

while ((result34 = regexp.exec(str))) {
  console.log(`Найдено ${result34[0]} на позиции ${result34.index}`);
  // Найдено JavaScript на позиции 9, затем
  // Найдено javascript на позиции 31
}

// Метод regexp.test(str) ищет совпадение и возвращает true/false, в зависимости от того, находит ли он его.

// Например:

str = "Я люблю JavaScript";

// эти два теста делают одно и то же
console.log(/люблю/i.test(str)); // true
console.log(str.search(/люблю/i) != -1); // true

// Пример с отрицательным ответом:
str = "Ля-ля-ля";

console.log(/люблю/i.test(str)); // false
console.log(str.search(/люблю/i) != -1); // false

// Если регулярное выражение имеет флаг g, то regexp.test ищет, начиная с regexp.lastIndex и обновляет это свойство, аналогично regexp.exec.

// Таким образом, мы можем использовать его для поиска с заданной позиции:

regexp = /люблю/gi;
str = "Я люблю JavaScript";

// начать поиск с 10-й позиции:
regexp.lastIndex = 10;
console.log(regexp.test(str)); // false (совпадений нет)

regexp = /javascript/g; // (regexp только что создан: regexp.lastIndex=0)

console.log(regexp.test("javascript")); // true (теперь regexp.lastIndex=10)
console.log(regexp.lastIndex);
console.log(regexp.test("javascript")); // false
// Чтобы обойти это, можно присвоить regexp.lastIndex = 0 перед новым поиском. Или вместо методов на регулярном выражении вызывать методы строк str.match/search/..., они не используют lastIndex.
// console.log
